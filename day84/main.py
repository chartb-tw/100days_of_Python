import datetime as dt

import tkinter as tki
from tkinter import filedialog, messagebox
import numpy # as np
import colorsys
from PIL import Image


image_file_types = [
			("Image types", ("*.png", "*.PNG", "*.jpg", "*.JPG", "*.jpeg", "*.JPEG", "*.gif", "*.GIF")),
			("All file types", "*.*"),
			]
"""
            ("PNG Images", ("*.png", "*.PNG")),
            ("JPEG Images", ("*.jpg", "*.JPG", "*.jpeg", "*.JPEG")),
            ("GIF Images", ("*.gif", "*.GIF"))
        ] 
"""

# code from CodeDrome = https://gist.github.com/CodeDrome/396027221a95ba22d800ae937e6e6f16#file-rgbhsl-py
# the method I am planning to use is similar to that taken in Object Oriented Structures under C++:
# "The luminance of every pixel of the second image is checked, if that
# pixel's luminance is 1 (100%), then the pixel at the same location on
# the first image has its luminance increased by 0.2."
# of course, this requires the file to be "of an expected form" (i.e. the watermark should be all white),
# but that can be handled at some point later.

def create_hls_array(image):
	
	"""
	Creates a numpy array holding the hue, lightness
	and saturation values for the Pillow image.
	"""
	
	pixels = image.load()
	
	hls_array = numpy.empty(shape=(image.height, image.width, 3), dtype=float)
	
	for row in range(0, image.height):
	
		for column in range(0, image.width):
			rgb = pixels[column, row]
	
			hls = colorsys.rgb_to_hls(rgb[0]/255, rgb[1]/255, rgb[2]/255)
	
			hls_array[row, column, 0] = hls[0]
			hls_array[row, column, 1] = hls[1]
			hls_array[row, column, 2] = hls[2]
	
	return hls_array


def image_from_hls_array(hls_array):
	
	"""
	Creates a Pillow image from the HSL array
	generated by the create_hls_array function.
	"""
	
	new_image = Image.new("RGB", (hls_array.shape[1], hls_array.shape[0]))
	
	for row in range(0, new_image.height):
	
		for column in range(0, new_image.width):
			rgb = colorsys.hls_to_rgb(hls_array[row, column, 0],
									  hls_array[row, column, 1],
									  hls_array[row, column, 2])
	
			rgb = (int(rgb[0]*255), int(rgb[1]*255), int(rgb[2]*255))
			new_image.putpixel((column, row), rgb)
	
	return new_image

# program start

window = tki.Tk()

window.title("File processor")
window.config(padx=50, pady=50)

filename = None
wm_fname = None

def UploadAction(event=None):
	ask_filename = filedialog.askopenfilename(filetypes=image_file_types) # the filetypes parameter of askopenfilename is optional, but allows for only specific file types to be selected or to filter by separate types
	if len(ask_filename)!=0:
		global filename
		filename = ask_filename
		file_label.config(text = f"File chosen: {filename}")

def wm_upla(event=None):
	ask_filename = filedialog.askopenfilename(filetypes=image_file_types) # the filetypes parameter of askopenfilename is optional, but allows for only specific file types to be selected or to filter by separate types
	if len(ask_filename)!=0:
		global wm_fname
		wm_fname = ask_filename
		wmf_label.config(text = f"File chosen: {wm_fname}")

def clear_chosen_file(event=None):
	global filename, wm_fname
	filename = None
	wm_fname = None
	file_label.config(text = "Select file:")
	wmf_label.config(text = "Choose watermark:")

def wm_pic():
	global filename
	if (filename is not None) and (wm_fname is not None):
		try:	
			"""
			# this else is unnecessary, as the filename won't be defined when called below!
			else:
				raise NameError("No file has been selected") # raise (throw) a NameError if no file was defined
			"""
			with Image.open(filename) as img:
				inp_img_hls = create_hls_array(img)
				#print(filename, img.format, f"{img.size}x{img.mode}")
				with Image.open(wm_fname) as wmim:
					wm_img_hls = create_hls_array(wmim)
					for x in range(inp_img_hls.shape[0]):
						for y in range(inp_img_hls.shape[1]):
							if (x < wm_img_hls.shape[0]) and (y < wm_img_hls.shape[1]):
								if wm_img_hls[x,y,1]==1: # if the watermark's luminance is equal to 1, then
									inp_img_hls[x,y,1] = min(inp_img_hls[x,y,1] + 0.2, 1) # increase it by 0.2 (or set it to 1 if that result is greater than 1)
					output_image = image_from_hls_array(inp_img_hls)
					output_image.save(f"watermarked_image_{dt.datetime.now().strftime('%Y%b%d-%H%M%S')}.{img.format}", quality=95)
						
						
					
			#print(f"Watermark filename: \"{wm_fname}\"")
		except FileNotFoundError: # a file could be deleted/moved after it was selected
			messagebox.showerror(title= "Error opening input file", message=f"The file:\n{filename}\" could not be found. Was the file deleted or moved after selection?")
		except OSError: # an OSError is raised if the file cannot be opened
			messagebox.showerror(title= "Error opening input file", message=f"There was an error in trying to open:\n{filename}\nCheck e.g. if the file is a valid image format?")
		else:
			messagebox.showinfo(title = "Success", message = "No errors occurred in the processing of the file.")
			clear_chosen_file()
		finally:
			pass
	else:
		messagebox.showwarning(title="Select a file", message = "Please provide both the watermark image and the file to be watermarked")
	
	
	
	
"""
watermark_label = tki.Label(text = "Choose text:")
watermark_label.pack()

watermark_entry = tki.Entry(width = 35)
watermark_entry.pack()

# to get the contents, use watermark_entry.get()
"""

wmf_label = tki.Label(text = "Choose watermark:")
wmf_label.pack()

wmf_button = tki.Button(window, text='Select watermark', command=wm_upla)
wmf_button.pack()

file_label = tki.Label(text = "Select file:")
file_label.pack()

upload_button = tki.Button(window, text='Select image', command=UploadAction)
upload_button.pack()

clear_button = tki.Button(window, text='Clear files', command=clear_chosen_file)
clear_button.pack()

process_button = tki.Button(window, text='Process', command=wm_pic)
process_button.pack()

window.mainloop()

